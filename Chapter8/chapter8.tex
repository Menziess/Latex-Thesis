%!TEX root = ../thesis.tex
%*******************************************************************************
%****************************** Eighth Chapter *********************************
%*******************************************************************************
\graphicspath{{Chapter8/Figs/Vector/}{Chapter8/Figs/}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Recommendations
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
\chapter{Recommendations}

\section{Frontend}
The first non-functional requirement states that the solution should be seamlessly integrated in the portal. On top of that, a user shouldn’t have to log in again to make use of the pricing service from within that portal. Iframes, objects and embeds have been mentioned as potential solutions to integrate a frontend in several distinct portals. This problem affects more than just the pricing project, therefore a decision must be made on a higher level before the frontend will be integrated, but the decision is not required for the first sprint to start. The options that are available are: an integrated view inside the existing DispatchAPI project or a separate solution built in Vue2 with a material design style that can be integrated using an iframe.

\section{Backend}
The backend should be loosely coupled, but should be accessible by all users who are able to authenticate and authorize themselves. It’s advised to implement the system as a microservice, because it separates the concern effectively. By implementing the system as a module, the implementation is entirely dependent on the existing system it’s implemented in, stalling modernization of architecture in the long run. The solution that is presented in the pregame solves this challenge by having one microservice handle the requests that are in some cases routed through the DispatchAPI. The requests sent by a user from any portal should be directed at the microservice, while price calculation requests should be routed through the DispatchAPI. Loopback should be used as a framework, preferably in combination with typescript.

\section{Functionalities}
The core functionality of the system is to calculate a price based on rules defined by the user. The user is able to define which Dispatch API application installations (DaAppInstallations) may use these rules, but also which debtors may use these rules. If a ride is booked by the passenger, the passenger may be entitled to a discount if he or she orders the ride while being related to a debtor that is linked to a discount, or if the company has discounts that are matched with the ride. In this case other rules may apply. In any other case, the rules that are tied to the DaAppInstallation from which a ride is booked are used.

The other main functionality encapsulates all the steps that a user must take to set up the prices for the company. By generalizing concepts such as time and place as much as possible, the user can reason about his decisions more easily. For example, a location can be defined as a collection of zip codes, a collection of points or a collection of area’s. To be more concrete, a user may define a location named ‘Falke Hotels’, using a list of zip codes. Next the user draws an area on top of Schiphol to define another location. Now these locations may be used in a rule that defines fixed prices from Falke Hotels to Schiphol. The user selects the price, the start location and end location he has just defined. The user also wants to give passengers that have a relation with the Falke debtor have a 10% discount on fridays. The user creates a discount, fills in 10% discount and adds a timeframe within which this discount is applicable. The user selects ‘add timeframe’, and  selects the hours of the week in a timeframe view. He selects all the hours on friday and names this timeframe ‘fridays’. The user connects the rule and the discount to a debtor name ‘Falke’, now all the passengers will pay fixed prices from hotels to Schiphol with a 10% discount on friday.

A passenger who books a ride from a Falke hotel requests the price, as he’s tied to a debtor, he sends a debtor identifier to the system. The API selects the rules that are tied to the debtor (if no rules are tied, the system will fall back on rules defined for the DaAppInstallation) within the company. The API tries to find a departure location that matches with a rule. But the passenger travels to amsterdam, not to Schiphol, therefore no rule was found. The API finds a dynamic pricing rule, so the price is calculated using a start price, price per kilometer and price per minute. The passenger has ordered an electric limousine (defined as a custom vehicle type by the user), so the most expensive tariffs are used. The passenger also lets the limousine wait for 10 minutes, so the price goes up a bit. Because it’s friday, the passenger is lucky to have a 10% discount and passes a bulk threshold at 30 kilometers traveled, lowering the price per kilometer from that point onward. As the electric limousine reaches the location in Amsterdam, the driver adds a small additional fee on top of the calculated price because the passenger spilled a drink inside the limousine, which is handled outside of the price calculation.

All the steps demonstrated in the story can be handled by the proposed system functionalities and data structure as explained in the Phase I - Pregame document. Some edge cases like layered area’s are resolved by defining precedences on rules and discounts. The edge case of having a neighbour profit from hotel discounts, is by having rules and discounts be tied to debtors. The edge case of having to define many hotels by drawing area’s around them on a map can be handled by defining specific points instead. The edge case of no rules being found is resolved by returning an error, this may be subject to change.

\subsection{Authentication section Authorization}
When speaking about microservices, authentication is the immediate next concern. If requests can be sent to the microservice directly, there must be a solution implemented to authenticate and authorize the user autonomously. As with the frontend discussion, this matter is of importance if more microservices are implemented in the future. It may be beneficial to introduce a single solution of authentication and authorization. This is suggested in the document by implementing an authentication server that provides a token that can be validated at a microservice level. If this is not desired, a similar authentication flow can be implemented as described by Marco as used in current systems.

\section{Database}
MongoDB should be used over an SQL database because of its scalability. MongoDB supports geographical location types, geospatial queries including the predicate to check which polygons contain a single point, or retrieving all points contained within a single polygon.

\subsection{section Interface}
The user interface will contain an overview showing the main concepts that a user has to maintain: pricing rules, locations, discounts. The UI should be focussed on linear navigation with overviews of detail pages. The UI will contain a screen to assign rules and discounts to DaAppInstallations and debtors, a screen to define locations, a screen to edit rules, a screen to modify vehicle types, and a screen to define timeframes.
