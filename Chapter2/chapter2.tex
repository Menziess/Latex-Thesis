%!TEX root = ../thesis.tex
%*******************************************************************************
%****************************** Second Chapter *********************************
%*******************************************************************************
\graphicspath{{Chapter2/Figs/Vector/}{Chapter2/Figs/}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Encoding Locations
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% - In what way can locations be represented to be universally interpretable
%   and precise?
%
\chapter{Encoding Locations}
\section{Introduction}
Encoding of locations has historically been of great importance, and is always being modernized. This chapter explains the general definition of locations, which types of locations are important for this project, and how to represent these locations so that they are universally interpretable and do not rely on a postal code system.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% A Brief History Of Geographic Locations
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% - How did the history of navigation evolve?
% - Who and what played a big role in navigation?
%
\section{A Brief History Of Geographic Locations}
A location is roughly described as a place or position. Throughout history, various navigational techniques and tools like the sextant, nautical chart and marinner's compass were used, measuring the altitude of the North Star to determine the latitude $\phi$, in conjunction with a chronometer to determine the longitude $\lambda$ of a location on the Earth's surface. The combination of coordinates is a distinct encoding of a location. This particular system is still commonly used today.

\begin{figure}[htbp!]
	\centering
	\includegraphics[width=.2\textwidth]{LatLngSphere}
	\caption[LatLngSphere]{A perspective view of the Earth showing how latitude and longitude are defined on a spherical model.}
	\label{fig:latlngsphere}
\end{figure}

The history of this encoding goes way back to when it was first proposed in the 3rd century BC by Eratosthenes. He invented the discipline of geography, and was known for also being the first person to calculate the circumference of the Earth with remarkable accuracy. Today, navigation relies on satellites that are capable of providing information to determine a location with a precision of 9 meters. Hybrid methods using cell towers, Wi-Fi Location Services, and the new Galileo global navigation sattelite system, provide tracking with a precision down to the meter range. These locations are ordinarily communicated using the same established latitude and longitude encoding. For a human being, it is not practical to exchange day-to-day locations as geographical coordinates. For that, addresses much more suitable, but can be ambiguous, imprecise, and inconsistent in format. Addresses commonly make use of Postal Code systems, which have reliably been assigned to geographical areas with the purpose of sorting mail. Although even today, there are countries that do not have a Postal Code system. This forces the legacy system to support addresses for the fixed pricing functionality as well. In contrast to the geographic coordinate system, postal codes describe streets and areas of varying shapes and sizes. A location being roughly described as a place or position, can be decomposed as an abstract term to describe physical or imaginary areas with varying radiusses and shapes. You could prepend 'the location of' to the following terms as an example: America, the birthplace of Sokrates, Wall Street, the center of the universe, the Laryngeal Nerve of the Giraffe, churches in the Netherlands. The final example presents the main challenge of this project, how to communicate the location of a collection with points or areas of differing shapes and sizes that may overlap?

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Requisites of Location types
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% - What do we need to describe our type of locations?
% - What do we not need?
% - Which location types matter for this project?
% - What are the main differences between postal systems used around the globe?
% - Can postal codes be abstracted to geospatial data while retaining the same
%   usefulness in the system?
%
\section{Requisite Location Types}
While setting up a backlog for a project, a shared knowledge about the terminology used in the issues must be achieved in order to collaborate effectively. Words or symbols do not have an absolute meaning, and ambiguity of abstract linguistic terms should be elucidated. In section 3.2.1 of Appendix \ref{appendix:pregame}, an agreement was made on what the terms "area" and "point" meant. The MySQL documentation notes that "The term most commonly used is geometry, defined as a point or an aggregate of points representing anything in the world that has a location." in \cite{MySQL-Spat}. During the process of implementing TPS, the definitions of a location have been refined to represent a common and useful understanding.

\subsection{The Point}
A point is a unique place expressed as a distinct coordinate pair. An address in the legacy system could be translated to a point. For example, the address that is tied to Schiphol arrival is: Aankomstpassage, 1118 AX Schiphol Centrum.
The point that encodes this location is (52.308891, 4.760900). This location is contained in the set of all possible points on Earth, which could be expressed using set builder notation:
\[P = \{(\phi,\lambda) \in \mathbb{R}^2 | -90 < \phi < 90, -180 < \lambda < 180 \}\]
\[(52.308891, 4.760900) \in P\]
A point itself can not be used to match whether another point is contained within it, because the probability of a match is infitesimal. Only when decimals were disregarded to decrease the precision of a point it would be possible, in which case it would still not be usefull in this application, because the imprecise point would be a square.

\subsection{The Area}
An area is a set of points points with an infinite granularity. This definition allows for an area to have holes inside them, consist of other locations and contain other locations, and be infinitely precise. The most useful property of this area is to check whether a point is contained within the area, or which areas contain a given point. For this to be the case, the points must be packed together as it would form a shape. This definition, however conceptually valuable, will not be of much practical use. For example, $P$ is an infinitely long set of coordinates, an area that represents the earths surface. If $\phi$ ranged between 0 and 90, the set sould describe all points located in the northern hemisphere, but would still be infinitely long. Checking whether a given point is contained by checking an infinite amount of real number pairs will take an infinite amount of time in the worst case scenario. An area can be described as a subset of all points:
\[a_1 \subseteq P \]
The set of all possible areas can be defined by the power set of P:
\[A = \mathcal{P}(P)\]
such that a subset of points, called an area, is in all possible areas A:
\[a_1 \in A\]
At the equator, 1 degree is 111320m, so 0.000001 degrees is
around 11cm. Six decimal places will be sufficient for location matching for this application. But even when reducing coordinates to having six decimal places, it would be impractical. For this reason, it is more realistic to only describe the rough edges of an area using a polygon shape. Instead of checking for a single point in a non-terminating iteration over all points in an area, a mathematical calculations could be used to check whether a unique point is contained within the polygon.

\subsection{Postal Codes, Addresses, and Polygons}
All postal codes that start with a ten describe the city of Amsterdam, the entire area of Amsterdam can be drawn as a big polygon containing all the postal codes that start with a ten.

\begin{figure}[H]
	\centering
	\includegraphics[width=.8\textwidth]{Amsterdam}
	\caption[Amsterdam]{Amsterdam - A single location contrived of multiple locations.}
	\label{fig:Amsterdam}
\end{figure}

In reverse, this procedure would not work. If a polygon was drawn cutting Amsterdam in half diagonally, a single postal code pattern would never be flexible or precise enough to be able to describe the boundaries of the polygon. One big taxi company making use of taxiID's legacy system is located in the United Arab Emirates. This company would not be able to convert anything at all, because the United Arab Emirates does not have a postal code system to begin with.

\begin{figure}[H]
	\centering
	\includegraphics[width=.8\textwidth]{PostalCodes}
	\caption[PostalCodes]{Postal codes by country with amount of digits ranging from three digits (lightblue) to eight digits (darkgreen) and no postal code system (gray).}
	\label{fig:postalcodes}
\end{figure}

When a trip is booked in the United Arab Emirates, the only information provided as a destination or departure location are geospatial coordinates and addresses. These addresses are compared with long lists of matching addresses in the legacy database, as previously described with postal codes. Addresses and postal code systems do not provide universally interpretable and precise encodings of locations, especially for the locations that matter for this project: points and areas. Addresses can be ambiguous, addresses and postal codes can be imprecise, postal codes are not uniform, and some countries do not have a postal code system. In contrast, polygons would provide unique and precise location definition that is uniform and universal. But postal codes and addresses have been useful in the legacy system. When moving to other encoding techniques, this usefulness must be preserved.

\subsection{Requirements for Location Matching}
If the following statements are true for a given location encoding using the definitions of the Point and Area, the location encoding is useful and able to operate independently from the postal code and address systems.

\begin{table}[htbp!]
	\centering
	\begin{tabular}{l|l}
		\toprule
		Nr & Description \\
		\midrule
		1. & Every location is stored in a database as a single entity \\
		\hline
		2. & \makecell[l]{Locations can consist of multiple locations \\
			(see figure \ref{fig:Amsterdam})} \\
		\hline
		3. & \makecell[l]{A deterministic predicate of whether a location is \\
			fully contained within a location is achievable} \\
		\hline
		4. & \makecell[l]{A deterministic method of finding all locations \\
			containing a single location can be used} \\
		\hline
		5. & \makecell[l]{A method of determining precedence of location in case \\
			of overlap must always yield one result, and discard all others} \\
		\hline
		6. & \makecell[l]{Locations must be importable from external sources} \\
		\bottomrule
	\end{tabular}
	\caption[Location Matching Requirements]{Location Matching Requirements}
	\label{tab:location-matching-requirements}
\end{table}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Literature review
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% - Storing location data
% - Querying location data
% - Intersecting
% - Research different countries
% - 3 words, gps, geospatial
%
\section{Literature Review}
Many spatial database systems support a basic Geometry hierarchy of Points, Polygons, MultiPoint and MultiPolygon Classes, as described in the OGC~\cite{SFA} and ISO 19125~\cite{ISO-19125} standard. These spatial datatypes would could be stored as single entities. The MultiPolygon class is able to support multiple polygons to be stored as a single entity. The standard provides containment predicate, and methods to distinguish larger locations from smaller ones, which could be used in precedence checks. Databases like MySQL and PostgreSQL provide similar functionalities that adhere to the OGC standard, while MongoDB has its own implementation. These functionalities can be seen as a straight forward approach in solving geometry based queries.
What 3 words, a multi-award winning global addressing system, bases 3m x 3m squares, covering the planet, on a combination of three words. In their whitepaper: "Efficient and future-proof", CEO Chris Cheldrick explains how locations can be communicated more effectively by describing a three by three meter areas using three words \cite{w3w}. The what3words API offers functionalities that can find what3word geocodings near a specified latitude and longitude location. It is also able to find results within a clamped area, as documented in \cite{w3w-api}. This system could be used to retrieve area's as three words in a database with given clamp parameters, which could then be stored in the database as single entities. This system would solve the problem of having ambiguity in address or postal code systems, and it is also very accurate. But in order to provide complex polygon matching, a spatial database system is still required. If a radius was assigned to the centroid of the shape that is formed by the boundaries of the street, neighbourhood, province or country, the encoding could technically be defined as a what3words query. A combination of clustering of points around what3word encodings could provide a system that is far less accurate, but is usable.

\mynote{Keep trying to find if other people found solutions for determining precedence of polygon matches}
http://geoawesomeness.com/discrete-global-grid-system-dggs-new-reference-system/

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Database Prerequisites
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% - Which Database Management Systems (DBMS) cover the location storage use
%   cases for this project?
%
\section{Database Prerequisites}
The database that is used must be able to determine whether a polygon contains a given point, and must be able to aggregate all points that are contained within a given polygon. The scenario presented in image \ref{fig:square} should be replicable.

\begin{figure}[htbp!]
	\centering
	\includegraphics[width=.5\textwidth]{Square}
	\caption[Square]{Four Points, one Polygon p containing Point c.}
	\label{fig:square}
\end{figure}

As contained in Appendix \ref{appendix:pregame}, this example provides a proof that a minimal requirement is satisfied, so that a list of candidate Database Management Systems could be constructed.

\subsection{OpenGIS Compatible databases}
MYSQL’s innate integrity is a good reason to opt for a full MYSQL database setup. MariaDB is a fork of MYSQL that performs better according to benchmarks, however they don’t always translate to real life situations. It’s easy to migrate from MYSQL to MariaDB, so choosing MYSQL at first could be preferable as an instance of MYSQL is already used at TaxiID. PostgreSQL offers a spatial database extender for that is OpenGIS compliant called PostGIS that adds support for geographic objects and location queries.

All spatial data types inherit properties such as type and spatial reference identifier (SRID). For rigorous documentation, both PostGIS documentation \cite{PostGIS} and MYSQL documentation \cite{MySQL} could be consulted. When a generic geometry column, or point column is created, points can be inserted as shown in snippet \ref{lst:sql-insert-points}.

\begin{lstlisting}[caption={Insert four points and one polygon in MySQL.}, label={lst:sql-insert-points}]
	START TRANSACTION;
	SET @a = ST_GeomFromText('POINT(1 1)');
	INSERT INTO point (point) VALUES (@a);
	SET @b = ST_GeomFromText('POINT(2.5 2.5)');
	INSERT INTO point (point) VALUES (@b);
	SET @c = ST_GeomFromText('POINT(5 5)');
	INSERT INTO point (point) VALUES (@c);
	SET @d = ST_GeomFromText('POINT(-2.5 -2.5)');
	INSERT INTO point (point) VALUES (@a);
	# also insert @b, @c, and @d
	COMMIT;

	START TRANSACTION;
	# First and last point should be the same
	SET @a = PolygonFromText('POLYGON((2.5 5,5 7.5,7.5 5,5 2.5,2.5 5))');
	INSERT INTO polygon (polygon) VALUES (@a);
	COMMIT;
\end{lstlisting}

It is evident that c is contained in p. To determine which points are contained in p, the function as seen in Snippet \ref{lst:sql-pts-in-poly} can be used, which returns the point with coordinates $[5, 5]$ as expected.


\begin{lstlisting}[caption={Select points contained in polygon, and all polygons containing a point in MySQL.}, label={lst:sql-pts-in-poly}]
	// All points contained in polygon
	SELECT ST_ASTEXT(POINT)
	FROM POINT
	WHERE
	ST_CONTAINS(
		(
			SELECT POLYGON
			FROM POLYGON
			WHERE id = 1
		),
		POINT
	)

	// All polygons containing point
	SELECT ST_ASTEXT(POLYGON)
	FROM POLYGON, POINT
	WHERE
		POINT.id = 3 AND ST_CONTAINS(
			POLYGON.polygon,
			POINT.point
		)
\end{lstlisting}

\subsection{OpenGIS Incompatible databases}
MongoDB doesn’t offer OpenGIS implementations but has geospatial query operators that may provide enough functionalities for current requirements \cite{MongoDB}. The argument for choosing one over the other depends on the vast differences between SQL and NoSQL, next to performance and extensiveness of geospatial features. The setup displayed in image \ref{fig:square} is recreated in MongoDB using queries shown in snippets \ref{lst:nosql-insert-points} and \ref{lst:nosql-pts-in-poly}.

\begin{lstlisting}[caption={Insert four points and one polygon in MongoDB.}, label={lst:nosql-insert-points}]
	db.point.insertMany([
		{ shape: { type: "Point", coordinates: [1, 1] } },
		{ shape: { type: "Point", coordinates: [2.5, 2.5] } },
		{ shape: { type: "Point", coordinates: [5, 5] } },
		{ shape: { type: "Point", coordinates: [-2.5, -2.5] } },
	])

	db.polygon.insert({
		shape: {
			type: "Polygon",
			coordinates: [ [ [2.5, 5], [5, 7.5], [7.5, 5], [5, 2.5], [2.5, 5] ] ]
		}
	})

	db.point.createIndex({ 'shape': '2dsphere' })
	db.polygon.createIndex({ 'shape': '2dsphere' })
\end{lstlisting}

\begin{lstlisting}[caption={Select points contained in polygon, and all polygons containing a point in MongoDB.}, label={lst:nosql-pts-in-poly}]
	// All points contained in polygon
	var p = db.polygon.find({})

	db.point.find({
		shape: {
			$geoWithin: {
				$polygon: [
					[2.5, 5],
					[5, 7.5],
					[7.5, 5],
					[5, 2.5],
					[2.5, 5]
				]
			}
		}
	})

	// All polygons containing point
	var p = db.point.findOne({ coordinates: [5, 5] })

	db.polygon.find({
		shape: {
			$geoIntersects: {
				$geometry: {
					type: "Point",
					coordinates: [5, 5]
				}
			}
		}
	})
\end{lstlisting}

Next to database solutions for this requirement, services exist that are capable of geofencing. Although these services may not be free, and the added dependencies restrict extensibility.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Performance and Clustering Trade-offs
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
\section{Performance and Clustering Trade-offs}
Agarwal and Rajan state that NoSQL take advantage of cheap memory and processing power, thereby handling the four V’s of big data more effectively,
but lack the robustness over SQL databases in \cite{AGS}. The report dives deeper into spatial queries and concludes that their tests suggest that MongoDB performs better by an average factor of 10, which increases exponentially as the data size increases, but lack many spatial functions that OpenGIS supports. Although improvements have been made, as per \cite{MongoDB-Performance}. After the paper Schmid et al. 2015 \cite{SCS} was published. The team argues that clustering is much easier in MongoDB, which may be important in the future when the company grows. As the required functionalities exist in both SQL and NoSQL, it is beneficial to opt for MongoDB for its performance and alignment with the teams experience. Although if robustness is desired, or extra GIS functionalities required, SQL should be taken into consideration.
